# Седмица 11 - Стек и опашка

## Задача 01 - Стек
Напишете алгебричен тип данни `Stack`, представляващ стек от елементи от произволен тип. Напишете следните функции за работа със стек:

- `emptyS :: Stack a` - създава празен стек
- `push :: a -> Stack a -> Stack a` - добавя елемент на върха на стека и връща променения стек
- `peek :: Stack a -> Maybe a` - връща елемента на върха на стека, ако не е празен
- `pop :: Stack a -> Maybe (a, Stack a)` - премахва елемента на върха на стека (ако го има) и връща наредена двойка, съдържаща премахнатия елемент и променения стек
- `isEmptyS :: Stack a -> Bool` - проверява дали стекът е празен

### Пример:
```hs
ghci> isEmptyS emptyS -- True
ghci> peek $ push 3 emptyS -- Just 3
ghci> peek $ push 5 $ push 3 emptyS -- Just 5
ghci> pop $ push 5 $ push 3 emptyS -- (Just 5,Stack [3])
ghci> isEmptyS $ push 7 $ push 2 $ push 5 $ push 3 emptyS -- False
```

## Задача 02 - Опашка
Напишете алгебричен тип данни `Queue`, представляващ опашка от елементи от произволен тип. Напишете следните функции за работа с опашка:

- `emptyQ :: Queue a` - създава празна опашка
- `enqueue :: a -> Queue a -> Queue a` - добавя елемент в края на опашката и връща пременената опашка
- `headQ :: Queue a -> Maybe a` - връща елемента в началото на опашката, ако не е празна
- `dequeue :: Queue a -> Maybe (a, Queue a)` - премахва елемента в началото на опашката (ако го има) и връща наредена двойка, съдържаща премахнатия елемент и променената опашка
- `isEmptyQ :: Queue a -> Bool` - проверява дали опашката е празна

### Пример:
```hs
ghci> isEmptyQ emptyQ -- True
ghci> headQ $ enqueue 4 emptyQ -- Just 4
ghci> headQ $ enqueue 7 $ enqueue 4 emptyQ -- Just 4
ghci> dequeue $ enqueue 7 $ enqueue 4 emptyQ -- (Just 4,Queue [7] [])
ghci> isEmptyQ $ enqueue 6 $ enqueue 8 $ enqueue 7 $ enqueue 4 emptyQ -- False

test = do
  (n, s1) <- pop $ push 7 $ push 2 $ push 5 $ push 3 emptyS
  (p, s2) <- pop s1
  return p
```

## Задача 03 - Постфиксен запис
Напишете функция, която приема символен низ, представляващ аритметичен израз в инфиксен запис. Функцията да връща израза, трансформиран в постфиксен запис. Не е нужно да се правят валидации на входа.

### Бонус:
Напишете функция, която приема символен низ, представляващ аритметичен израз в постфиксен запис. Функцията да връща оценката на израза.

### Пример:
```hs
ghci> toPrefix "(1+2)*(3-4/5)" -- "12+345/-*"
ghci> toPrefix "(1+2)*(3/4-5)" -- "12+34/5-*"
```

## Задача 04 - Следващ по-голям елемент
Напишете функция, която приема списък от цели числа и за всяко число от списъка, връща кое е първото число надясно от него, което е по-голямо от него (ако няма такова, да се изведе -1). 

### Пример:
```hs
ghci> nextHigher [4,5,2,25] -- [5,25,25,-1]
ghci> nextHigher [13,7,6,12] -- [-1,12,12,-1]
```

## Задача 05 - Двоични числа
Напишете функция, която генерира безкраен списък от всички двоични числа (представете двоичните числа като низове).

### Пример:
```hs
ghci> take 10 binaries -- ["0","1","10","11","100","101","110","111","1000","1001"]
```

## Задача 06 - Обхождане на дърво в широчина

### Пример:
```hs
ghci> let testTree = Node 5
                     (Node 1
                           (Node 4
                                 Empty
                                 (Node 13 Empty Empty))
                           (Node 3 Empty Empty))
                     (Node 8
                           (Node 0
                                 (Node 10 Empty Empty)
                                 (Node 9 Empty Empty))
                           (Node 11 Empty Empty))

ghci> bfs testTree -- [5,1,8,4,3,0,11,13,10,9]
```

## Задача 07 - Числа на Hamming
Напишете функция, която генерира безкраен списък от числата на Hamming. Казваме, че едно число е число на Hamming, ако то може да се представи като 2<sup>x</sup>.3<sup>y</sup>.5<sup>z</sup>.

### Пример:
```hs
ghci> take 15 hamming -- [1,2,3,4,5,6,8,9,10,12,15,16,18,20,24]
```