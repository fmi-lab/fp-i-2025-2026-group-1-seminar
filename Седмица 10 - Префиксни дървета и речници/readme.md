# Седмица 10 - Префиксни дървета и речници

## Задача 01 - Речник
Напишете клас `Dictionary` обединяващ всички типове, които реализират операциите на структурата от данни речник, където ключовете са от тип `String`. Тези функции са:

- `empty :: Dictionary d => d a` - създава празен речник
- `singleton :: Dictionary d => String -> a -> d a` - създава речник с единствен ключ и стойност, равни на подадените
- `lookup :: Dictionary d => String -> d a -> Maybe a` - връща стойността, отговаряща на подадения ключ, ако съществува
- `insert :: Dictionary d => String -> a -> d a -> d a` - по подаден ключ и стойност, ако ключът е част от речник заменя стойността му с подадената, иначе го добавя 
- `toList :: Dictionary d => d a -> [(String, a)]` - по подаден речник, връща асоциативен списък от елементите в речника

### Бонус:
Добавете долните функции към дефиницията на `Dictionary`:

- `delete :: Dictionary d => String -> d a -> d a` - премахва от речника елемента с ключ, равен на подадения 
- `alter :: Dictionary d => (Maybe a -> Maybe a) -> String -> d a -> d a` - прилага функция върху елемент от речника с ключ равен на подадения, дори да липсва такъв елемент: представлява обобщение на добавяне, промяна и изтриване на елемент в речник.

Реализирайте `insert` и `delete` чрез `alter`.

## Задача 02 - Асоциативни списъци
Дефинирайте алгебричен тип `Assoc`, представляващ асоциативен списък, който приема 2 типови аргумента - един за типа на ключовете и един за типа на стойностите на елементите в списъка. Направете инстанция на класа `Dictionary` за асоциативен списък, в който ключовете са от тип `String`.

## Задача 03 - Префиксно дърво
Напишете алгебричен тип данни `Trie`, който представлява реализация на префиксно дърво. Направете инстанция на класа `Dictionary` за префиксно дърво.

Напишете следните допълнителни функции за работа с префиксни дървета:

- `fromList :: Assoc String a -> Trie a` - конструира префиксно дърво по подаден асоциативен списък
- `allWords :: Trie a -> [String]` - връща всички думи в префиксното дърво (дума наричаме всеки префикс, който съдържа стойност)
- `autocomplete :: String -> Trie a -> [String]` - по подадено префиксно дърво, връща всички думи в дървото, които започват с подадения префикс

### Примери:
```hs
ghci> fromList $ Assoc [("to", 5), ("inn", 8), ("in", 3), ("tone", 11)]
{- 
_
  └─ t:
    _
      └─ o:
        5
          └─ n:
            _
              └─ e:
                11
  └─ i:
    _
      └─ n:
        3
          └─ n:
            8
-}

ghci> allWords $ fromList $ Assoc [("to", 5), ("inn", 8), ("in", 3), ("tone", 11)]
-- ["to","tone","in","inn"]

ghci> autocomplete "ton" $ fromList $ Assoc [("to", 5), ("inn", 8), ("in", 3), ("tone", 11), ("tonic", 6)]
-- ["tonic","tone"]
```

## Задача 04 - Общи задачи за речници
Използвайте речник, за да решите следните задачи:

- `groupBy :: Dictionary d => (a -> String) -> [a] -> d [a]` - групира елементи на списък спрямо функция, задаваща низов критерий
- `histogram :: Dictionary d => [String] -> d Int` - по подаден списък от низове, връща хистограма на списъка. Хистограмата съдържа наредени двойки от уникалните елементи на списъка и броя на срещането им
- `intersection :: Dictionary d => d a -> d a -> d a` - приема два речника и връща нов речник, съдържащ тези елементи от първия, за които съществува елемент със същия ключ във втория

Разгледайте вградената реализация на речник от модула [Data.Map](https://hackage-content.haskell.org/package/containers-0.8/docs/Data-Map-Lazy.html). Използвайте тази реализация за решаването на горните задачи. Направете инстанция на `Dictionary` за `Map`, в който ключовете са от тип `String`.

### Пример:
```hs
ghci> groupBy (show . length) [[1, 2, 3], [1], [7, 2], [0], [8, 1, 6]] :: Trie [[Int]]
{-
_
  └─ 3:
    [[1,2,3],[8,1,6]]
  └─ 1:
    [[1],[0]]
  └─ 2:
    [[7,2]]
-}

ghci> groupBy (show . length) [[1, 2, 3], [1], [7, 2], [0], [8, 1, 6]] :: M.Map String [[Int]]
-- fromList [("1",[[1],[0]]),("2",[[7,2]]),("3",[[1,2,3],[8,1,6]])]

ghci> toList (histogram ["the","cat","and","the","dog","and","the","mouse","and","the","cat"] :: Trie Int)
-- [("cat",2),("the",4),("and",3),("mouse",1),("dog",1)]

ghci> histogram ["the","cat","and","the","dog","and","the","mouse","and","the","cat"] :: M.Map String Int
-- fromList [("and",3),("cat",2),("dog",1),("mouse",1),("the",4)]

ghci> intersection (M.fromList [("a", 5), ("b", 3)]) (M.fromList [("a", 10), ("c", 7)])
-- fromList [("a",5)]
```