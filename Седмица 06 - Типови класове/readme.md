# Седмица 06 - Типови класове

## Задача 01 - Класът Monoid
Напишете своя версия на класа `Semigroup` и чрез нея напишете своя версия на класа `Monoid`. `Semigroup` обединява всички типове, поддържащи асоциативна бинарна операция, а `Monoid` обединява всички типове, които инстанцират `Semigroup` и в допълнение имат неутрален елемент спрямо операцията. Направете следните инстанции на класа `Monoid`:

- за типа `Int` спрямо събирането
- за всички числови типове спрямо събирането и умножението
- за типа `Nat` от предния път относно събирането/умножението
- за типа `Maybe`, когато типовият аргумент е също `Monoid` 

## Задача 02 - Класът Foldable
Разгледайте класа `Foldable` от стандартната библиотека и за него направете следните инстанции:

- за типoвете `Maybe` и `Either` от предния път
- за типа `Chain` от предния път

## Задача 03 - JSON сериализация
Дефинирайте клас `JsonSerializable` който обединява всички типове, които могат да се сериализират в JSON формат. Класът да дефинира две функции:

- `toJson`, която приема стойност от даден тип и връща стойност от тип `Json` представляващ структурата на JSON обекта
- `toJsonString`, която приема стойност от даден тип и връща сериализирания JSON обект под формата на символен низ

Направете инстанция на класа `JsonSerializable` за типа `Student` от предния път. Направете инстанция на класа `Show` за типа `Json`, така че `show` да конвертира JSON обект в правилен формат.

Напишете функция `serializeStudents`, която приема списък от студентите в едно училище и връща списъка в JSON формат. Използвайте класа `Monoid` от първата задача.

### Пример:
```haskell
ghci> let student1 = Student "3MI0800092" "Georgi Atanasov" "nigosto@gmail.com" Nothing

ghci>  let student2 = Student "0MI0800065" "Rosen Kolev" "master_troppical@gmail.com" (Just "0888547128")

ghci> serializeStudents [student1, student2]
{-

[{
  "fn": 3MI0800092,
  "name": Georgi Atanasov,
  "email": nigosto@gmail.com,
  "phone": null
}, {
  "fn": 0MI0800065,
  "name": Rosen Kolev,
  "email": master_troppical@gmail.com,
  "phone": 0888547128
}]

-}
```

## Задача 04 - Класът Functor
Напишете своя версия на класа `Functor` обединяващ в себе си всички типове, поддържащи трансформация на съставящите ги стойности. Класът да съдържа функцията `fmap` и нейният вариант като оператор - `<$>`, които "повдигат" функция на някакви типове до функция на фуктори от тези типове. Направете следните инстанции на класа `Functor`:

- за типoвете `Maybe` и `Either` от предния път
- за списъци и типа `Chain` от предния път
- за наредени двойки и функции (какъв проблем забелязвате)
