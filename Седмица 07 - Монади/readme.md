# Седмица 07 - Монади

## Задача 01 - От функтори, през апликативни функтори до монади
Използвайки вашата реализация на функтор от предния път, направете ваша реализация на класа `Applicative`, който обединява всички апликативни функтори. Апликативен функтор е функтор, който позволява последователно изпълнение на дадени трансформации.

Използвайки вашата реализация на апликативен функтор, направете ваша реализация на класа `Monad`. Монадите са апликативни функтори, които позволяват последователно изпълнение на дадени трансформации, които могат да използват предишните резултати.

Направете инстанции на класа `Monad` за типовете `Maybe`, `Either` и `Chain` от по-предния път. 

**Важно**: Ако искате да използвате `do` нотацията, трябва да направите инстанция на вградения клас `Monad`.

### Пример за Maybe
```haskell
safeDiv :: Double -> Double -> Maybe Double
safeDiv _ 0 = Nothing
safeDiv a b = Just $ a / b

composeMaybe :: Double -> Maybe Double
composeMaybe d = do
  let x = 100
  y <- safeDiv x 5
  z <- safeDiv y d
  safeDiv z 8

ghci> composeMaybe 4 -- Just 0.625
ghci> composeMaybe 0 -- Nothing
```

### Пример за Chain
```haskell
composeChain :: Chain Int
composeChain = do
  x <- Append (Singleton 1) (Singleton 2)
  y <- Append (Singleton 10) (Singleton 20)
  return (x + y)
  
ghci> composeChain -- Append (Append (Singleton 11) (Singleton 21)) (Append (Singleton 12) (Singleton 22))
```

## Задача 02 - Монадата IO
Запознайте се с монадата IO. Използвайте IO, за да напишете следните функции:

- `getValue :: Read a => IO a` - прочита стойност от даден тип от стандартния вход
- `getValues :: Read a => IO [a]` - прочита списък от стойности от даден тип от стандартния вход
- `printList :: Show a => String -> [a] -> IO ()` - приема списък и разделител и извежда елементите на списъка на стандартния изход разделени с разделителя като след последния елемент да се изведе нов ред
- `untilValid :: Read a => String -> (a -> Bool) -> IO a` - приема съобщение, което да бъде изведено на екрана и предикат. Функцията се опитва да прочете стойност от стандартния вход, като ако тя не е валидна спрямо предиката, подканва потребителя да въведе нова стойност

## Задача 03 - Работа с файлове
Използвайки монадата IO, напишете следните функции за работа с файлове:

- `countLines :: String -> IO Int` - по подадено име на файл, намира броя на редовете в него
- `toEveryUpper :: String -> IO ()` - прочита файл с подаденото име и го записва като трансформира първата буква на всяка дума в главна
- `wordFrequency :: String -> IO [(String, Int)]` - прочита файл с подаденото име и връща списък от наредени двойки, където първите компоненти са думите във файла, а вторите - колко пъти се срещат
- `grep :: String -> String -> IO [String]` - приема име на файл и символен низ и връща всички редове от файла, които съдържат низа  
- `encodeRot13 :: String -> String -> IO ()` - приема имена на два файла. Прочита съдържанието на първия файл, кодира го чрез `ROT13` шифъра и запазва резултата във втория файл (ако не съществува го създава) 

## Задача 04 - Запазване на информация за студенти
Напишете **програма**, която прочита три команди от потребителя: "ADD", "LIST" и "EXIT". 

При получаване на команда "ADD", потребителя бива подканен да въведе необходимата информация за създаване на студент, след което я валидира и при успех създава студента, а в противен случай извежда подходящо съобщение за грешка.

При получаване на команда "LIST", изкарва на стандартния изход записаните до момента студенти.

При получаване на команда "EXIT", програмата спира да обработва повече команди и записва информацията за студентите във файл с име students.json в JSON формат.

При получаване на невалидна команда, потребителят да бъде подканен отново да въведе команда. При опит за създаване на студент с вече съществуващ факултетен номер, програмата да извежда подходящо съобщение.

## Бонус: Монадата State
Дефинирайте тип State, който съдържа една единствена стойност - функция `runState`, която приема тип `s` представляващ текущо състояние, и връщаща наредена двойка от тип `(a, s)`, където първата компонента е резултатът от прилагането на функцията върху текущото състояние, а втората компонента е новото състояние, което се получава след прилагането на функцията. Направете инстанция на класа `Monad` за този тип.

Използвайки State, направете симулация на банкови транзакции. Напишете следните функции:

- `deposit :: Int -> State Int ()` - депозира (добавя) пари към банкова сметка
- `withdraw :: Int -> State Int Bool` - опитва да изтегли пари от банкова сметка. Ако транзакцията е успешна, резултатът е `True` и сметката намалява с подадения брой пари, иначе резултатът е `False` и сметката остава непроменена

Ако сте реализирали правилно функциите, трябва следният код да се компилира успешно и да връща резултат `(True, 120)`:

```haskell
session :: State Balance Bool
session = do
  deposit 100
  success <- withdraw 30
  deposit 50
  return success

ghci> runState session 0 -- (True, 120)
```
