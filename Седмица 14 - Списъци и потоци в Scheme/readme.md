# Седмица 14 - Списъци и потоци в Scheme

```scheme
(define (foldr operation null_value lst)
  (if (null? lst) null_value
      (operation (car lst)
          (foldr operation null_value (cdr lst)))))

(define (foldl operation null_value lst)
  (if (null? lst) null_value
      (foldl operation (operation null_value (car lst)) (cdr lst))))

(define (filter pred? lst)
  (foldr (lambda (current result)
           (if (pred? current)
               (cons current result)
               result)) '() lst))
```

## Задача 01 - Търсене по предикат
Напишете функция `find`, която приема списък и предикат, и намира първия елемент в списъка, който отговаря на предиката.

```scheme
(find '(5 7 13 3 6 23 18 11) even?) ; -> 6
(find '(5 7 13 3 6 23 18 11) (lambda (x) (< x 0))) ; -> #f
```

## Задача 02 - Сливане
Напишете функция `zip`, която приема 2 списъка, и връща списък от наредени двойки, където първият елемент на двойката на позиция `i` е елементът в първия списък на позиция `i`, а вторият елемент е съответно елементът на позиция `i` във втория.

### Пример:
```scheme
(zip '(1 2 3 4) '("a" "b" "c")) ; -> '((1 . "a") (2 . "b") (3 . "c"))
```

## Задача 03 - Най-дълъг подсписък
Напишете функция `max-repeated`, която приема списък, и връща дължината на най-дългия подсписък, който съдържа еднакви елементи.

### Пример:
```scheme
(max-repeated '(1 1 2 3 3 3 4 2 2 2 2 1 1)) ; -> 4
```

## Задача 04 - Обединение и сечение
Напишете функции `union` и `intersection`, които правят съответно обединение и сечение на два списъка. Редът на елементите в резултата няма значение.

### Пример:
```scheme
(union '(1 2 4 "a" #t) '(5 6 1 "b" #f "a")) ; -> '(1 2 4 "a" #t 5 6 "b" #f)
(intersection '(1 2 4 "a" #t) '(5 6 1 "b" #f "a")) ; -> '(1 "a")
```

## Задача 05 - Най-малък елемент в списък
Напишете функция, която намира най-малкия елемент в списък. Задачата да се реши без каквато и да е рекурсия.

## Задача 06 - Средно аритметично
Напишете функция, която смята средното аритметично на произволен брой аргументи.

### Пример:
```scheme
(average 1 2 3 4 5) ; -> 3
```

## Задача 07 - Вариадичен `map`
Реализирайте вариант на `map`, който работи над произволен брой списъци.

### Пример:
```scheme
(map-var + '(1 2 3) '(4 5 6) '(7 8 9)) ; -> '(12 15 18)
```

```scheme
(define-syntax cons-stream
  (syntax-rules () ((cons-stream h t)
                    (cons h (delay t)))))

(define head car)
(define (tail s) (force (cdr s))) 
```

## Задача 08 - Естествени числа
Напишете функция, която генерира безкраен поток от всички естествени числа.

### Пример:
```scheme
(take 10 nats) ; -> '(0 1 2 3 4 5 6 7 8 9)
```

## Задача 09 - Map за потоци
Напишете функция `map-stream`, която е аналогът на `map`, но за потоци.

### Пример:
```scheme
(take 10 (map-stream (lambda (x) (* x x)) nats)) ; -> '(0 1 4 9 16 25 36 49 64 81)
```

## Задача 10 - Сливане на потоци с функция
Напишете функция `zip-with-stream`, която е аналогът на `zip-with`, но за потоци.

### Пример:
```scheme
(take 10 (zip-with-stream + nats fibs)) ; -> '(0 2 3 5 7 10 14 20 29 43)
```

## Задача 11 - Фибоначи
Напишете функция, която генерира безкраен поток от числата на Фибоначи

## Пример:
```scheme
(take 10 fib) ; -> '(0 1 1 2 3 5 8 13 21 34)
```

## Задача 12 - Триъгълник на Паскал
Напишете функция, която генерира безкраен поток от списъци, представляващи редовете от тригълника на Паскал.

## Пример:
```scheme 
(take 5 pascal-triangle) ; -> '((1) (1 1) (1 2 1) (1 3 3 1) (1 4 6 4 1))
```

## Задача 13 - Безкрайни суми (второ контролно 2017)
Напишете функция, която по подадени 2 положителни числа `k` и `n` генерира безкраен поток, в който първото число е `k`, а всяко следващо е сумата на предните `n` числа.

### Пример:
```scheme
(take 10 (sum-last 3 5)) ; -> '(3 3 6 12 24 48 93 183 360 708)
```